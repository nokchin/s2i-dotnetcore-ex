@{

      uint[] midstate = {0xc022dc5f,0x48274e98,0x6e353555,0x47bfc523,0x4811a092,0x207c9749,0x7657c67e,0x562a335c};
      string bits_expo = "17";   //I have run real cshtml experiment, and found that (unlike in Javascript) string in cshtml must be inside double-quote... cshtml string in single quote will NOT work (based on real experiment).
      string bits_coef = "0x7e578c";
      string merkleroot= "76dc896b48d682e80c6e96368649634e57742a1eeb171dd97c259ce0c6d6a757";
      string mintime = "d1b45d5a";
      string bits = "8c577e17";

      uint blocktemplate=0;    // make 'blocktemplate' become a GLOBAL variable here.

      string nonce1 = "6e19b093";   // = 1847177363 (decimal)  ->  2 million less than the required/correct nonce value.   [Other value pairs:  0x6e28f2d3 = 1848177363 (decimal) ]
      string nonce2 = "0";  //I have tested with real cshtml experiment on RedHat OpenShift platform with zero 'nonce2' value, and my cshtml program below can really terminate/exit the 'do-while' loop properly.

      uint[] h = {0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
                  0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
                  0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
                  0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
                  0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
                  0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
                  0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
                  0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2};

      uint[] m = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
      m[0] = uint.Parse(merkleroot.Substring(56,8), System.Globalization.NumberStyles.HexNumber);   // cannot use  int.Parse()  here, because m[] is a 'uint' array.
      m[1] = uint.Parse(mintime, System.Globalization.NumberStyles.HexNumber); 
      m[2] = uint.Parse(bits, System.Globalization.NumberStyles.HexNumber);
      m[3] = uint.Parse(nonce1, System.Globalization.NumberStyles.HexNumber);  // m[3] is nonce (use hex number here, just to follow the convention used in 'MineBitcoin1' Javascript code).
      m[4] = 0x80000000;
      m[15] = 0x00000280;
      for (int i=16; i<18; i++) { m[i]= ((m[i-15]<<25| (m[i-15]>>7) )^(m[i-15]<<14| (m[i-15]>>18) )^ (m[i-15]>>3) )+m[i-7]+((m[i-2]<<15| (m[i-2]>>17) )^(m[i-2]<<13| (m[i-2]>>19) )^ (m[i-2]>>10) )+m[i-16];   }

      uint[] mm = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
      mm[8]=0x80000000;
      mm[15]=0x00000100;

      uint midvalue0=midstate[0];  uint midvalue1=midstate[1];  uint midvalue2=midstate[2];  uint midvalue3=midstate[3];
      uint midvalue4=midstate[4];  uint midvalue5=midstate[5];  uint midvalue6=midstate[6];  uint midvalue7=midstate[7];
for (int i=0; i<3; i++) {
      blocktemplate = h[i]+midvalue7+(midvalue4&midvalue5^~midvalue4&midvalue6)+((midvalue4<<26| (midvalue4>>6) )^(midvalue4<<21| (midvalue4>>11) )^(midvalue4<<7| (midvalue4>>25) ))+m[i];
      midvalue7=midvalue6;               // reg_h  <-  reg_g
      midvalue6=midvalue5;               // reg_g  <-  reg_f
      midvalue5=midvalue4;               // reg_f  <-  reg_e
      midvalue4=midvalue3+blocktemplate;       // reg_e  <-  reg_d + T1
      blocktemplate= blocktemplate+((midvalue0<<30| (midvalue0>>2) )^(midvalue0<<19| (midvalue0>>13) )^(midvalue0<<10| (midvalue0>>22) ))+(midvalue0&midvalue1^midvalue0&midvalue2^midvalue1&midvalue2);       // (T1+T2) = T1 + Sigmabig0(a) + Maj(a,b,c)
      midvalue3=midvalue2;               // reg_d  <-  reg_c
      midvalue2=midvalue1;               // reg_c  <-  reg_b
      midvalue1=midvalue0;               // reg_b  <-  reg_a
      midvalue0=blocktemplate;           // reg_a  <-  (T1+T2)
}

/*
do {
      uint reg_a=midvalue0;   uint reg_b=midvalue1;   uint reg_c=midvalue2;   uint reg_d=midvalue3;
      uint reg_e=midvalue4;   uint reg_f=midvalue5;   uint reg_g=midvalue6;   uint reg_h=midvalue7;
for (int i=3; i<64; i++) {
      if (i>=18) { m[i]= ((m[i-15]<<25| (m[i-15]>>7) )^(m[i-15]<<14| (m[i-15]>>18) )^ (m[i-15]>>3) )+m[i-7]+((m[i-2]<<15| (m[i-2]>>17) )^(m[i-2]<<13| (m[i-2]>>19) )^ (m[i-2]>>10) )+m[i-16];   }     // need to re-calculate $m[18] to $m[63] everytime the nonce $m[3] changes.
      blocktemplate= h[i]+reg_h+(reg_e&reg_f^~reg_e&reg_g)+((reg_e<<26| (reg_e>>6) )^(reg_e<<21| (reg_e>>11) )^(reg_e<<7| (reg_e>>25) ))+m[i];
      reg_h=reg_g;               // reg_h  <-  reg_g
      reg_g=reg_f;               // reg_g  <-  reg_f
      reg_f=reg_e;               // reg_f  <-  reg_e
      reg_e=reg_d+blocktemplate;   // reg_e  <-  reg_d + T1
      blocktemplate= blocktemplate+((reg_a<<30| (reg_a>>2) )^(reg_a<<19| (reg_a>>13) )^(reg_a<<10| (reg_a>>22) ))+(reg_a&reg_b^reg_a&reg_c^reg_b&reg_c);   // (T1+T2) = T1 + Sigmabig0(a) + Maj(a,b,c)
      reg_d=reg_c;               // reg_d  <-  reg_c
      reg_c=reg_b;               // reg_c  <-  reg_b
      reg_b=reg_a;               // reg_b  <-  reg_a
      reg_a=blocktemplate;       // reg_a  <-  (T1+T2)
}

      mm[0]=reg_a+midstate[0];   mm[1]=reg_b+midstate[1];   mm[2]=reg_c+midstate[2];   mm[3]=reg_d+midstate[3];
      mm[4]=reg_e+midstate[4];   mm[5]=reg_f+midstate[5];   mm[6]=reg_g+midstate[6];   mm[7]=reg_h+midstate[7];

      reg_a=0x6a09e667;   reg_b=0xbb67ae85;   reg_c=0x3c6ef372;   reg_d=0xa54ff53a;
      reg_e=0x510e527f;   reg_f=0x9b05688c;   reg_g=0x1f83d9ab;   reg_h=0x5be0cd19;

for (int i=0; i<64; i++) {
      if (i>=16) { mm[i]= ((mm[i-15]<<25| (mm[i-15]>>7) )^(mm[i-15]<<14| (mm[i-15]>>18) )^ (mm[i-15]>>3) )+mm[i-7]+((mm[i-2]<<15| (mm[i-2]>>17) )^(mm[i-2]<<13| (mm[i-2]>>19) )^ (mm[i-2]>>10) )+mm[i-16]; }   // need to re-calculate $mm[16] to $mm[63] everytime $mm[0]-$mm[7] change.
      blocktemplate= h[i]+reg_h+(reg_e&reg_f^~reg_e&reg_g)+((reg_e<<26| (reg_e>>6) )^(reg_e<<21| (reg_e>>11) )^(reg_e<<7| (reg_e>>25) ))+mm[i];
      reg_h=reg_g;               // reg_h  <-  reg_g
      reg_g=reg_f;               // reg_g  <-  reg_f
      reg_f=reg_e;               // reg_f  <-  reg_e
      reg_e=reg_d+blocktemplate;  // reg_e  <-  reg_d + T1
      if (i==60) {   //(i==60)'s output reg_e will become (i==63)'s output reg_h.
        if (reg_e+0x5be0cd19) {break;}  //[VERY IMPORTANT]: MUST have ending semicolon at   "break;"  . If not, RedHat OpenShift PHP interpreter will give error.
      }
      if (i==61) {   //(i==61)'s output reg_e will become (i==63)'s output reg_g.
        if (reg_e+0x1f83d9ab) {break;}  //[VERY IMPORTANT]: MUST have ending semicolon at   "break;"  . If not, RedHat OpenShift PHP interpreter will give error.
      }
      if (i==62) {   //(i==62)'s output reg_e will become (i==63)'s output reg_f.
//      if (bits_expo=="17") {
          string str = (reg_e+0x9b05688c).ToString("x8");    // 'str' is now a hex string with 8-characters (with leading zeroes padded if necessary).
          if (str.Substring(6,2)!="00") {break;}
          if (uint.Parse(str.Substring(4,2)+str.Substring(2,2)+str.Substring(0,2),System.Globalization.NumberStyles.HexNumber) < uint.Parse(bits_coef.Substring(2,6),System.Globalization.NumberStyles.HexNumber)) {    //success!

            str = m[3].ToString("x8");
          //<p>@str</p>;
            break 2;
          }
          else {break;}  //[VERY IMPORTANT]: MUST have ending semicolon at   "break;"  . If not, RedHat OpenShift PHP interpreter will give error.
//      }
      }
      blocktemplate= blocktemplate+((reg_a<<30| (reg_a>>2) )^(reg_a<<19| (reg_a>>13) )^(reg_a<<10| (reg_a>>22) ))+(reg_a&reg_b^reg_a&reg_c^reg_b&reg_c);   // (T1+T2) = T1 + Sigmabig0(a) + Maj(a,b,c)
      reg_d=reg_c;
      reg_c=reg_b;
      reg_b=reg_a;
      reg_a=blocktemplate;
}

      m[3]=m[3]+1;
  } while (  m[3] != uint.Parse(nonce2,System.Globalization.NumberStyles.HexNumber)   );   //better use hex number here, because Javascript maximum POSITIVE decimal integer/number is until 2,147,483,647 only.
*/

    <p>DONE!</p>

}